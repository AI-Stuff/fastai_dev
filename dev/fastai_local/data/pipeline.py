#AUTOGENERATED! DO NOT EDIT! File to edit: dev/02_data_pipeline.ipynb (unless otherwise specified).

__all__ = ['Transform', 'Pipeline']

from ..imports import *

from ..test import *

from ..core import *


@docs
class Transform():
    "A function that `encodes` if `filt` matches, and optionally `decodes`, with an optional `setup`"
    order,filt = 0,None

    def __init__(self, encodes=None, **kwargs):
        if encodes is not None: self.encodes=encodes
        for k,v in kwargs.items(): setattr(self, k, v)

    @classmethod
    def create(cls, f, filt=None):
        "classmethod: Turn `f` into a `Transform` unless it already is one"
        return f if hasattr(f,'decode') or isinstance(f,Transform) else cls(f)

    def _filt_match(self, filt): return self.filt is None or self.filt==filt
    def __call__(self, o, filt=None, **kwargs): return self.encodes(o, **kwargs) if self._filt_match(filt) else o
    def decode  (self, o, filt=None, **kwargs): return self.decodes(o, **kwargs) if self._filt_match(filt) else o
    def __repr__(self): return str(self.encodes) if self.__class__==Transform else str(self.__class__)
    def decodes(self, o, *args, **kwargs): return o

    _doc=dict(__call__="Call `self.encodes` unless `filt` is passed and it doesn't match `self.filt`",
              decode="Call `self.decodes` unless `filt` is passed and it doesn't match `self.filt`",
              decodes="Override to implement custom decoding")

class Pipeline():
    "A pipeline of transforms applied to a collection, composed and applied for encode/decode, and setup one at a time"
    def __init__(self, tfms, items=None):
        self.items,self.tfms = items,[]
        self.add([Transform.create(t) for t in listify(tfms)])

    def add(self, tfms):
        "Call `setup` on all `tfms` and append them to this pipeline"
        for t in sorted(listify(tfms), key=lambda o: getattr(o, 'order', 0)):
            self.tfms.append(t)
            if hasattr(t, 'setup'): t.setup(self)

    def __call__(self, x, **kwargs): return self.composed(x, **kwargs)
    def decode(self, x, **kwargs): return self.composed(x, rev=True, fname='decode', **kwargs)
    def __eq__(self, b): return all_equal(self, b)
    def __len__(self): return len(self.items)
    def __getitem__(self, i):
        its = self.items[i]
        return [self(o) for o in its] if is_listy(its) else self(its)

    def composed(self, x, rev=False, fname='__call__', **kwargs):
        "Compose `{fname}` of all `self.tfms` (reversed if `rev`) on `x`"
        tfms = reversed(self.tfms) if rev else self.tfms
        for f in tfms: x = opt_call(f, fname, x, **kwargs)
        return x

    def __repr__(self): return str(self.tfms)
    def delete(self, idx): del(self.tfms[idx])
    def remove(self, tfm): self.tfms.remove(tfm)

    def __getattr__(self, k):
        "Find last tfm in `self.tfms` that has attr `k`"
        try: return next(getattr(t,k) for t in reversed(self.tfms) if hasattr(t,k))
        except StopIteration: raise AttributeError(k) from None

add_docs(
    Pipeline,
    __call__="Compose `__call__` of all `tfms` on `x`",
    decode="Compose `decode` of all `tfms` on `x`",
    delete="Delete transform `idx` from pipeline",
    remove="Remove `tfm` from pipeline",
)