#AUTOGENERATED! DO NOT EDIT! File to edit: dev/02_data_pipeline.ipynb (unless otherwise specified).

__all__ = ['opt_call', 'Transform', 'doc', 'Pipeline']

from fastai_local.imports import *
from fastai_local.test import *
from fastai_local.core import *

def opt_call(f, fname='__call__', *args, **kwargs):
    "Call `f.{fname}(*args, **kwargs)`, or `noop` if not defined"
    return getattr(f,fname,noop)(*args, **kwargs)

class Transform():
    "A function that `encodes` if `filt` matches, and optionally `decodes`, with an optional `setup`"
    order,filt = 0,None

    def __init__(self, encodes=None, **kwargs):
        if encodes is not None: self.encodes=encodes
        for k,v in kwargs.items(): setattr(self, k, v)

    @classmethod
    def create(cls, f, filt=None):
        "classmethod: Turn `f` into a `Transform` unless it already is one"
        return f if hasattr(f,'decode') or isinstance(f,Transform) else cls(f)

    def __call__(self, o, filt=None, **kwargs):
        "Call `self.encodes` unless `filt` is passed and it doesn't match `self.filt`"
        if self.filt is not None and self.filt!=filt: return o
        return self.encodes(o, **kwargs)

    def decode(self, o, filt=None, **kwargs):
        "Call `self.decodes` unless `filt` is passed and it doesn't match `self.filt`"
        if self.filt is not None and self.filt!=filt: return o
        return self.decodes(o, **kwargs)

    def __repr__(self): return str(self.encodes) if self.__class__==Transform else str(self.__class__)
    def decodes(self, o, *args, **kwargs): return o

def doc(cls):
    "Copy values from `cls._doc` to docstrings, and confirm all public methods are documented"
    for k,v in cls._doc.items(): getattr(cls,k).__doc__ = v
    # List of public callables without docstring
    nodoc = [c for n,c in cls.__dict__.items() if isinstance(c,Callable)
             and not n.startswith('_') and c.__doc__ is None]
    assert not nodoc, f"Missing docs: {nodoc}"
    assert cls.__doc__ is not None, f"Missing class docs: {cls}"
    return cls

@doc
class Pipeline():
    "A pipeline of transforms, composed and applied for encode/decode, and setup one at a time"
    def __init__(self, tfms):
        self.tfms,self.inactiv_tfms = [],[Transform.create(t) for t in listify(tfms)]

    def __call__(self, x, **kwargs): return self._apply(x, **kwargs)
    def decode(self, x, **kwargs): return self._apply(x, rev=True, fname='decode', **kwargs)

    def _apply(self, x, rev=False, fname='__call__', **kwargs):
        self.setup()
        tfms = reversed(self.tfms) if rev else self.tfms
        for f in tfms: x = opt_call(f, fname, x, **kwargs)
        return x

    def __repr__(self): return str(self.tfms)
    def delete(self, idx): del(self.tfms[idx])
    def remove(self, tfm): self.tfms.remove(tfm)

    def setup(self, items=None):
        tfms = self.inactiv_tfms
        self.inactiv_tfms = []
        self.add(tfms, items)

    def add(self, tfms, items=None):
        for t in sorted(listify(tfms), key=lambda o: getattr(o, 'order', 0)):
            f = getattr(t, 'setup', None)
            if f: t.setup(self(items))
            self.tfms.append(t)

    def __getattr__(self, k):
        for t in reversed(self.tfms):
            a = getattr(t, k, None)
            if a is not None: return a
        raise AttributeError(k)

    _doc=dict(
        __call__="Compose `__call__` of all `tfms` on `x`",
        decode="Compose `decode` of all `tfms` on `x`",
        delete="Delete transform `idx` from pipeline",
        remove="Remove `tfm` from pipeline",
        setup="Call `setup` on all `self.tfms` and make them active in this pipeline",
        add="Call `setup` on all `tfms` and append them to this pipeline",
        __getattr__="Find last tfm in `self.tfms` that has attr `k`",
    )