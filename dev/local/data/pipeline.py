#AUTOGENERATED! DO NOT EDIT! File to edit: dev/02a_pipeline.ipynb (unless otherwise specified).

__all__ = ['get_func', 'Func', 'Sig', 'SelfFunc', 'Self', 'compose_tfms', 'get_samples', 'mk_transform', 'Pipeline',
           'TfmdList', 'TfmdDS']

from ..imports import *
from ..test import *
from ..core import *
from .transform import *
from ..notebook.showdoc import show_doc

def get_func(t, name, *args, **kwargs):
    "Get the `t.name` (potentially partial-ized with `args` and `kwargs`) or `noop` if not defined"
    f = getattr(t, name, noop)
    return f if not (args or kwargs) else partial(f, *args, **kwargs)

class Func():
    "Basic wrapper around a `name` with `args` and `kwargs` to call on a given type"
    def __init__(self, name, *args, **kwargs): self.name,self.args,self.kwargs = name,args,kwargs
    def __repr__(self): return f'sig: {self.name}({self.args}, {self.kwargs})'
    def _get(self, t): return get_func(t, self.name, *self.args, **self.kwargs)
    def __call__(self,t): return L(t).mapped(self._get) if is_listy(t) else self._get(t)

class _Sig():
    def __getattr__(self,k):
        def _inner(*args, **kwargs): return Func(k, *args, **kwargs)
        return _inner

Sig = _Sig()

class SelfFunc():
    "Search for `name` attribute and call it with `args` and `kwargs` on any object it's passed."
    def __init__(self, nm, *args, **kwargs): self.nm,self.args,self.kwargs = nm,args,kwargs
    def __repr__(self): return f'self: {self.nm}({self.args}, {self.kwargs})'
    def __call__(self, o):
        if not is_listy(o): return getattr(o,self.nm)(*self.args, **self.kwargs)
        else: return [getattr(o_,self.nm)(*self.args, **self.kwargs) for o_ in o]

class _SelfFunc():
    def __getattr__(self,k):
        def _inner(*args, **kwargs): return SelfFunc(k, *args, **kwargs)
        return _inner

Self = _SelfFunc()

def compose_tfms(x, tfms, func_nm=None, reverse=False, **kwargs):
    "Apply all `func_nm` attribute of `tfms` on `x`, maybe in `reverse` order"
    if reverse: tfms = reversed(tfms)
    for f in tfms:
        if func_nm: f = getattr(f,func_nm,noop)
        x = f(x, **kwargs)
    return x

def get_samples(b, max_rows=10):
    if isinstance(b, Tensor): return b[:max_rows]
    return zip(*L(get_samples(b_, max_rows) for b_ in b))

def mk_transform(f):
    "Convert function `f` to `Transform` if it isn't already one"
    return f if isinstance(f,TransformBase) else Transform(f)

@docs
class Pipeline():
    "A pipeline of composed (for encode/decode) transforms, setup with types"
    def __init__(self, funcs=None):
        if isinstance(funcs, Pipeline): funcs = funcs.fs
        self.fs = L(funcs).mapped(mk_transform).sorted(key='order')

    def setup(self, items=None):
        tfms,self.fs = self.fs,[]
        for t in tfms: self.add(t,items)

    def add(self,t, items=None):
        if t.add_before_setup:     self.fs.append(t)
        getattr(t, 'setup', noop)(items)
        if not t.add_before_setup: self.fs.append(t)

    def __call__(self, o, filt=None): return compose_tfms(o, self.fs, filt=filt)
    def decode  (self, o, filt=None): return compose_tfms(o, self.fs, 'decode', reverse=True, filt=filt)
    def __repr__(self): return f"Pipeline: {self.fs}"
    def __getitem__(self,i): return self.fs[i]
    def decode_batch(self, b, filt=None, max_rows=10):
        return [self.decode(b_, filt=filt) for b_ in get_samples(b, max_rows=max_rows)]

    def show(self, o, ctx=None, filt=None, **kwargs):
        for f in reversed(self.fs):
            if hasattr(o, 'show'): return o.show(ctx)
            o = f.decode(o, filt=filt)
        if hasattr(o, 'show'): return o.show(ctx)

    _docs = dict(__call__="Compose `__call__` of all `tfms` on `o`",
                 decode="Compose `decode` of all `tfms` on `o`",
                 show="Show item `o`",
                 add="Add transform `t`",
                 decode_batch="`decode` all sample in a the batch `b`",
                 setup="Call each tfm's `setup` in order")

@docs
class TfmdList():
    "A `Pipeline` of `tfms` applied to a collection of `items`"
    def __init__(self, items, tfms, do_setup=True, parent=None):
        self.items,self.parent = L(items),parent
        if isinstance(tfms,Pipeline): self.tfms = tfms
        else:
            self.tfms = Pipeline(tfms)
            if do_setup: self.setup()

    def __getitem__(self, i): return self.get(i)
    def get(self, i, filt=None):
        "Transformed item(s) at `i`"
        its = self.items[i]
        if is_iter(i):
            if not is_iter(filt): filt = L(filt for _ in i)
            return L(self.tfms(it, filt=f) for it,f in zip(its,filt))
        return self.tfms(its, filt=filt)

    def setup(self): self.tfms.setup(self)
    def subset(self, idxs): return self.__class__(self.items[idxs], self.tfms, do_setup=False, parent=self)
    def decode_at(self, idx, filt=None): return self.decode(self.get(idx,filt=filt), filt=filt)
    def show_at(self, idx, filt=None, **kwargs): return self.show(self.get(idx,filt=filt), filt=filt, **kwargs)
    def __eq__(self, b): return all_equal(self, b)
    def __len__(self): return len(self.items)
    def __iter__(self): return (self[i] for i in range_of(self))
    def __repr__(self): return f"{self.__class__.__name__}: {self.items}\ntfms - {self.tfms}"
    def decode(self, *args, **kwargs): return self.tfms.decode(*args, **kwargs)
    def __call__(self, *args, **kwargs): return self.tfms.__call__(*args, **kwargs)
    def show(self, *args, **kwargs): return self.tfms.show(*args, **kwargs)

    _docs = dict(setup="Transform setup with self",
                 decode="From `Pipeline",
                 show="From `Pipeline",
                 decode_at="Decoded item at `idx`",
                 show_at="Show item at `idx`",
                 subset="New `TfmdList` that only includes items at `idxs`")

class TfmdDS(TfmdList):
    def __init__(self, items, type_tfms=None, ds_tfms=None, do_setup=True):
#         if type_tfms is None: type_tfms = [None]
        self.items = items
        self.tls = [TfmdList(items, t, do_setup=do_setup, parent=self) for t in L(type_tfms)]
        self.ds_tfms = Pipeline(ds_tfms)
        if do_setup: self.setup()
#         self.tls = [TfmdList(items, t, do_setup=do_setup, parent=self) for t in type_tfms]
#         self.__post_init__(items, ds_tfms, do_setup)

#     def __post_init__(self, items, ds_tfms, do_setup):
#         self.type_tfms = [it.tfms for it in self.tls]
#         self.ds_tfms = Pipeline(ds_tfms, t=[t_.final_t for t_ in self.type_tfms])

    def get(self, i, filt=None):
        its = [it.get(i, filt=filt) for it in self.tls]
        return self.ds_tfms(its, filt=filt)
#         its = _maybe_flat([it.get(i, filt=filt) for it in self.tls])
#         if is_iter(i):
#             if len(self.tls) > 1: its = zip(*L(its))
#             if not is_iter(filt): filt = L(filt for _ in i)
#             return L(self.ds_tfms(it, filt=f) for it,f in zip(its,filt))
#         return self.ds_tfms(its, filt=filt)

    def decode(self, o, filt=None):
        o = self.ds_tfms.decode(o, filt=filt)
        return [it.decode(o_, filt=filt) for o_,it in zip(o,self.tls)]
#         if not is_listy(o): o = [o]
#         return _maybe_flat([it.decode(o_, filt=filt) for o_,it in zip(o,self.tls)])

    def show(self, o, ctx=None, filt=None, **kwargs):
        o = self.ds_tfms.decode(o, filt=filt)
        for o_,it in zip(o,self.tls): ctx = it.show(o_, ctx=ctx, filt=filt, **kwargs)
        return ctx
#         if self.ds_tfms.t_show is not None: return self.ds_tfms.show(o, ctx=ctx, filt=filt, **kwargs)
#         o = self.ds_tfms.decode(o, filt=filt)
#         if not is_listy(o): o = [o]
#         for o_,it in zip(o,self.tls): ctx = it.show(o_, ctx=ctx, filt=filt, **kwargs)
#         return ctx

    def setup(self): self.ds_tfms.setup(self)

#     def subset(self, idxs):
#         return self.__class__(self.items[idxs], self.type_tfms, self.ds_tfms, do_setup=False)

#     def __repr__(self):
#         return f"{self.__class__.__name__}: {self.items}\ntype tfms - {self.type_tfms}\nds tfms - {self.ds_tfms}"

add_docs(TfmdDS,
         "A `Dataset` created from raw `items` by calling each element of `tfms` on them",
         get="Call all `tfms` on `items[i]` then all `tuple_tfms` on the result",
         decode="Compose `decode` of all `tuple_tfms` then all `tfms` on `i`",
         show="Show item `o` in `ctx`",
#          subset="New `TfmdDS` that only includes items at `idxs`",
         setup="Go through the transforms in order and call their potential setup on `items`")