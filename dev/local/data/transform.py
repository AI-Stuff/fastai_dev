#AUTOGENERATED! DO NOT EDIT! File to edit: dev/02_transforms.ipynb (unless otherwise specified).

__all__ = ['BasicTransform', 'cmp_instance', 'TupleTransform', 'TypeDispatch', 'TfmMeta', 'Transform']

from ..imports import *
from ..test import *
from ..core import *
from ..notebook.showdoc import show_doc

from types import MethodType

class BasicTransform():
    "Delegates (`__call__`,`decode`) to (`encodes`,`decodes`) if `filt` matches"
    filt=None
    def __init__(self, filt=None): self.filt=filt
    def __call__(self, *args, **kwargs): return self.call(True, *args, **kwargs)
    def decode  (self, *args, **kwargs): return self.call(False, *args, **kwargs)

    def func(self, is_enc, x, filt=None):
        if filt!=self.filt and filt is not None: return noop
        return self.encodes if is_enc else self.decodes

    def call(self, is_enc, x, *args, filt=None, **kwargs):
        f = self.func(is_enc, x, filt=filt)
        return f(x, *args, **kwargs)

    def encodes(self, x, *args, **kwargs): return x
    def decodes(self, x, *args, **kwargs): return x
#     def wrap(self, f, x, *args, filt=None, **kwargs):
#         return f(x, *args, **kwargs) if filt is None or self.filt is None or filt==self.filt else x

cmp_instance = functools.cmp_to_key(lambda a,b: 0 if a==b else 1 if issubclass(a,b) else -1)

def _p1_anno(f):
    "Get the annotation of first param of `f`"
    ann = [o for n,o in typing.get_type_hints(f).items() if n!='return']
    return ann[0] if ann else object

class TupleTransform(BasicTransform):
    "A `BasicTransform` that returns func applied to each element of `x` if it's listy"
    def __init__(self, enc=None, dec=None, filt=None):
        if enc: self.encodes = enc
        if dec: self.decodes = dec
        super().__init__(filt)

    def wrap(self, f, x, *args, **kwargs):
        sup = super().wrap
        t = _p1_anno(f)
        def _inner(x, *args, **kwargs): return f(x, *args, **kwargs) if isinstance(x,t) else x
        return [sup(_inner, x_, *args, **kwargs) for x_ in x
               ] if is_listy(x) else sup(_inner, x, *args, **kwargs)

class TypeDispatch:
    "Dictionary-like object; `__getitem__` matches keys of types using `issubclass`"
    def __init__(self, funcs=None):
        self.funcs = funcs or {}
        self._reset()

    def _reset(self):
        self.funcs = {k:self.funcs[k] for k in sorted(self.funcs, key=cmp_instance, reverse=True)}
        self.cache = {**self.funcs}

    def add(self, t, f):
        "Add type `t` and function `f`"
        self.funcs[t] = f
        self._reset()

    def __repr__(self): return str(self.funcs)
    def __getitem__(self, k):
        "Find first matching type that is a super-class of `k`"
        if k in self.cache: return self.cache[k]
        types = [f for f in self.funcs if issubclass(k,f)]
        res = self.funcs[types[0]] if types else None
        self.cache[k] = res
        return res

class TfmMeta(type):
    def __new__(cls, name, bases, dct):
        res = super().__new__(cls, name, bases, dct)
        res.fs = (TypeDispatch(),TypeDispatch())
        return res

    def __call__(cls, *args, **kwargs):
        f = args[0] if args else None
        if isinstance(f,Callable) and f.__name__ in ('decode','encode','_'):
            d = cls.fs[f.__name__ != 'decode']
            d.add(_p1_anno(f) or object, f)
            return f
        return super().__call__(*args, **kwargs)

class Transform(BasicTransform, metaclass=TfmMeta):
    def lookup(self, is_enc, x): return MethodType(self.fs[is_enc][type(x)] or noops, self)

    def wrap(self, f, x, *args, **kwargs):
        sup = super().wrap
        is_enc = f==self.encodes
        def _inner(x_, *args, **kwargs): return self.lookup(is_enc, x_)(x_, *args, **kwargs)
        return [sup(_inner, x_, *args, **kwargs) for x_ in x
               ] if is_listy(x) else sup(_inner, x, *args, **kwargs)