#AUTOGENERATED! DO NOT EDIT! File to edit: dev/02_transforms.ipynb (unless otherwise specified).

__all__ = ['anno_ret', 'cmp_instance', 'ShowTitle', 'Int', 'Float', 'Str', 'x_args', 'TransformBase', 'TransformWhole',
           'TypeDispatch', 'TfmMeta', 'Transform']

from ..imports import *
from ..test import *
from ..core import *
from ..notebook.showdoc import show_doc

from types import MethodType

def anno_ret(func):
    "Get the return annotation of `func`"
    ann = typing.get_type_hints(func)
    if not ann: return None
    typ = ann.get('return')
    return list(typ.__args__) if getattr(typ, '_name', '')=='Tuple' else typ

cmp_instance = functools.cmp_to_key(lambda a,b: 0 if a==b else 1 if issubclass(a,b) else -1)

def _p1_anno(f):
    "Get the annotation of first param of `f`"
    ann = [o for n,o in typing.get_type_hints(f).items() if n!='return']
    return ann[0] if ann else object

class ShowTitle:
    "Base class that adds a simple `show`"
    def show(self, ctx=None, **kwargs): return show_title(str(self), ctx=ctx)

class Int(int, ShowTitle): pass
class Float(float, ShowTitle): pass
class Str(str, ShowTitle): pass
add_docs(Int, "An `int` with `show`"); add_docs(Str, "An `str` with `show`"); add_docs(Float, "An `float` with `show`")

def x_args(x,*args): return (x,)+args if args else x

class TransformBase():
    "Delegates (`__call__`,`decode`) to (`encodes`,`decodes`) if `filt` matches"
    filt,add_before_setup,whole_tuple = None,False,False
    def __init__(self, filt=None, whole_tuple=False): self.filt,self.whole_tuple=filt,whole_tuple
    def __call__(self, *x, **kwargs): return self.call(True, *x, **kwargs)
    def decode  (self, *x, **kwargs): return self.call(False, *x, **kwargs)
    def encodes(self, x, *args, **kwargs): return x
    def decodes(self, x, *args, **kwargs): return x
    def __repr__(self): return f'Tfm {self.__class__.__name__}'

    def call(self, is_enc, *x, filt=None, **kwargs):
        if filt!=self.filt and self.filt is not None: return x
        if self.whole_tuple: return (self.encodes if is_enc else self.decodes)(*x, **kwargs)
        f = self.func(is_enc, *x)
        return tuple(self._do_call(f_, x_, **kwargs) for f_,x_ in zip(f,x))

    def func(self, is_enc, *x):
        f = self.encodes if is_enc else self.decodes
        t = _p1_anno(f)
        return tuple(f if isinstance(x_,t) else None for x_ in x)

    def _do_call(self, f, x, **kwargs):
        if f is None: return x
        res = f(x, **kwargs)
        typ_r = ifnone(anno_ret(f), type(x))
        return typ_r(res) if (type(res) != typ_r) and typ_r!=NoneType else res

class TransformWhole(TransformBase):
    "A convenience for `TransformBase(whole_tuple=True)`"
    def __init__(self, filt=None): super().__init__(filt=filt, whole_tuple=True)

class TypeDispatch:
    "Dictionary-like object; `__getitem__` matches keys of types using `issubclass`"
    def __init__(self, *funcs):
        self.funcs,self.cache = {},{}
        for f in funcs: self.add(f)

    def _reset(self):
        self.funcs = {k:self.funcs[k] for k in sorted(self.funcs, key=cmp_instance, reverse=True)}
        self.cache = {**self.funcs}

    def add(self, f):
        "Add type `t` and function `f`"
        self.funcs[_p1_anno(f) or object] = f
        self._reset()

    def __repr__(self): return str({getattr(k,'__name__',str(k)):v.__name__ for k,v in self.funcs.items()})
    def __getitem__(self, k):
        "Find first matching type that is a super-class of `k`"
        if k in self.cache: return self.cache[k]
        types = [f for f in self.funcs if issubclass(k,f)]
        res = self.funcs[types[0]] if types else None
        self.cache[k] = res
        return res

class TfmMeta(type):
    def __new__(cls, name, bases, dct):
        res = super().__new__(cls, name, bases, dct)
        res.fs = (TypeDispatch(),TypeDispatch())
        return res

    def __call__(cls, *args, **kwargs):
        f = args[0] if args else None
        if isinstance(f,Callable) and f.__name__ in ('decode','encode','_'):
            d = cls.fs[f.__name__ != 'decode']
            d.add(f)
            return f
        return super().__call__(*args, **kwargs)

class Transform(TransformBase, metaclass=TfmMeta):
    init_enc = False
    def __init__(self, enc=None, dec=None, filt=None):
        super().__init__(filt)
        self.init_enc = enc or dec
        if not self.init_enc: return
        self.fs = (TypeDispatch(),TypeDispatch())
        if enc: self.fs[True].add(enc)
        if dec: self.fs[False].add(dec)

    def lookup(self, is_enc, x):
        f = self.fs[is_enc][type(x)]
        return (f or noop) if self.init_enc else MethodType(f or noops, self)

    def func(self, is_enc, *x, filt=None): return [self.lookup(is_enc,x_) for x_ in x]

    def __repr__(self): return f'Tfm {self.fs}'