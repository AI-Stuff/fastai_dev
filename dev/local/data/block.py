#AUTOGENERATED! DO NOT EDIT! File to edit: dev/10_data_block.ipynb (unless otherwise specified).

__all__ = ['DataBlock', 'col_labeler', 'ColLabeler']

from ..imports import *
from ..test import *
from ..core import *
from .transform import *
from .pipeline import *
from .source import *
from .core import *
from .external import *
from ..notebook.showdoc import show_doc

from inspect import isfunction,ismethod

def _merge_tfms(*tfms):
    "Group the `tfms` in a single list, removing duplicates (from the same class) and instantiating"
    g = groupby(concat(*tfms), lambda o:
        o if isinstance(o, type) else o.__qualname__ if (isfunction(o) or ismethod(o)) else o.__class__)
    return L(sorted(v, key=lambda o: isinstance(o,type))[0] for k,v in g.items()).mapped(instantiate)

@docs
@funcs_kwargs
class DataBlock():
    "Generic container to quickly build `DataSource` and `DataBunch`"
    get_items=splitter=labeller = noops
    _methods = 'get_items splitter labeller'.split()
    def __init__(self, ts=None, **kwargs):
        types = L(getattr(self,'types',(float,float)) if ts is None else ts)
        self.default_type_tfms = types.mapped(
            lambda t: L(getattr(t,'create',None)) + L(getattr(t,'default_type_tfms',None)))
        self.default_ds_tfms = _merge_tfms(*types.attrgot('default_ds_tfms', L()), ToTensor)
        self.default_dl_tfms = _merge_tfms(*types.attrgot('default_dl_tfms', L()), Cuda)

    def datasource(self, source, type_tfms=None):
        self.source = source
        items = self.get_items(source)
        splits = self.splitter(items)
        labellers = [None,self.labeller] if isinstance(self.labeller, Callable) else self.labeller
        if type_tfms is None: type_tfms = [L() for t in self.default_type_tfms]
        type_tfms = L([self.default_type_tfms, type_tfms, labellers]).mapped_zip(
            lambda tt,tfm,l: L(l) + _merge_tfms(tt, tfm))
        return DataSource(items, tfms=type_tfms, filts=splits)

    def databunch(self, source, type_tfms=None, ds_tfms=None, dl_tfms=None, bs=16, **kwargs):
        dsrc = self.datasource(source, type_tfms=type_tfms)
        ds_tfms = _merge_tfms(self.default_ds_tfms, ds_tfms)
        dl_tfms = _merge_tfms(self.default_dl_tfms, dl_tfms)
        return dsrc.databunch(bs=bs, after_item=ds_tfms, after_batch=dl_tfms, **kwargs)

    _docs = dict(get_items="Pass at init or implement how to get your raw items from a `source`",
                 splitter="Pass at init or implement how to split your `items`",
                 labeller="Pass at init or implement how to label a raw `item`",
                 datasource="Create a `Datasource` from `source` with `tfms` and `tuple_tfms`",
                 databunch="Create a `DataBunch` from `source` with `tfms`")

def col_labeler(item, df, col, pref='', suff='', label_delim=None):
    "Label `item` looking in `col` of `df` with potention `pref` or `suff` and `label_delim`"
    res = pref + str(df[col][item]) + suff
    if label_delim is not None: res = [t for t in res.split(label_delim) if len(t)>0]
    return res

def ColLabeler(col, pref='', suff='', label_delim=None):
    "Retun a labeller for `col` when the `source` is a dataframe"
    def _inner(self, item): return col_labeler(item, self.source, col=col, pref=pref, suff=suff, label_delim=label_delim)
    return _inner

MultiCategory.default_type_tfms = OneHotEncode