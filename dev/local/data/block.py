#AUTOGENERATED! DO NOT EDIT! File to edit: dev/10_data_block.ipynb (unless otherwise specified).

__all__ = ['merge_tfms', 'DataBlock', 'col_labeler', 'ColLabeler']

from ..imports import *
from ..test import *
from ..core import *
from .transform import *
from .pipeline import *
from .source import *
from .core import *
from .external import *
from ..notebook.showdoc import show_doc

from inspect import isfunction,ismethod

def merge_tfms(*tfms):
    "Group the `tfms` in a single list, removing duplicates (from the same class) and instantiating"
    res,types = [],[]
    for ts in tfms:
        for t in L(ts):
            cls = t if isinstance(t, type) else t.__qualname__ if (isfunction(t) or ismethod(t)) else t.__class__
            if cls not in types or not isinstance(t, type):
                res = [f for f,t_ in zip(res,types) if t_ != cls]
                types = [t_ for t_ in types if t_ != cls]
                res.append(t() if isinstance(t, type) else t)
                types.append(cls)
    return res

@docs
@funcs_kwargs
class DataBlock():
    "Generic container to quickly build `DataSource` and `DataBunch`"
    get_items=splitter=labeller = noops
    _methods = 'get_items splitter labeller'.split()
    def __init__(self, ts=None, **kwargs):
        if ts is not None: self.types = ts
        self.default_type_tfms = {t: self._def_tfm(t) for t in self.types}
        self.default_ds_tfms = L(merge_tfms(*[getattr(t, 'default_ds_tfms', L()) for t in L(self.types)], ToTensor))
        self.default_dl_tfms = L(merge_tfms(*[getattr(t, 'default_dl_tfms', L()) for t in L(self.types)], Cuda))

    def _def_tfm(self, t):
        r = L(t.create if hasattr(t, 'create') else None)
        return r + L(getattr(t, 'default_type_tfms', None))

    def datasource(self, source, type_tfms=None):
        self.source = source
        items = self.get_items(source)
        splits = self.splitter(items)
        if type_tfms is None: type_tfms = [L() for t in self.types]
        type_tfms = L(merge_tfms(self.default_type_tfms[t], tfm) for (t,tfm) in zip(self.types, type_tfms))
        labellers = [None,self.labeller] if isinstance(self.labeller, Callable) else self.labeller
        type_tfms = L(L(l) + L(tfm) for l,tfm in zip(labellers, type_tfms))
        return DataSource(items, tfms=type_tfms, filts=splits)

    def databunch(self, source, type_tfms=None, ds_tfms=None, dl_tfms=None, bs=16, **kwargs):
        dsrc = self.datasource(source, type_tfms=type_tfms)
        ds_tfms = L(merge_tfms(self.default_ds_tfms, ds_tfms))
        dl_tfms = L(merge_tfms(self.default_dl_tfms, dl_tfms))
        return dsrc.databunch(bs=bs, after_item=ds_tfms, after_batch=dl_tfms, **kwargs)

    _docs = dict(get_items="Pass at init or implement how to get your raw items from a `source`",
                 splitter="Pass at init or implement how to split your `items`",
                 labeller="Pass at init or implement how to label a raw `item`",
                 datasource="Create a `Datasource` from `source` with `tfms` and `tuple_tfms`",
                 databunch="Create a `DataBunch` from `source` with `tfms`")

def col_labeler(item, df, col, pref='', suff='', label_delim=None):
    "Label `item` looking in `col` of `df` with potention `pref` or `suff` and `label_delim`"
    res = pref + str(df[col][item]) + suff
    if label_delim is not None: res = [t for t in res.split(label_delim) if len(t)>0]
    return res

def ColLabeler(col, pref='', suff='', label_delim=None):
    "Retun a labeller for `col` when the `source` is a dataframe"
    def _inner(self, item): return col_labeler(item, self.source, col=col, pref=pref, suff=suff, label_delim=label_delim)
    return _inner

MultiCategory.default_type_tfms = OneHotEncode