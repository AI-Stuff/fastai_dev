#AUTOGENERATED! DO NOT EDIT! File to edit: dev/09a_vision_data.ipynb (unless otherwise specified).

__all__ = ['ImageDataBunch', 'get_grid', 'clip_remove_empty', 'bb_pad', 'ImageBlock', 'ImageBWBlock', 'MaskBlock',
           'PointBlock', 'BBoxBlock', 'BBoxLblBlock']

#Cell
from ..test import *
from ..torch_basics import *
from ..data.all import *

from .core import *

#Cell
class ImageDataBunch(DataBunch):

    @classmethod
    @delegates(DataBunch.from_dblock)
    def from_folder(cls, path, train='train', valid='valid', valid_pct=None, seed=None, vocab=None, **kwargs):
        "Create from imagenet style dataset in `path` with `train`,`valid`,`test` subfolders (or provide `valid_pct`)."
        splitter = GrandparentSplitter(train_name=train, valid_name=valid) if valid_pct is None else RandomSplitter(valid_pct, seed=seed)
        dblock = DataBlock(types=(PILImage, Category(vocab=vocab)),
                           get_items=get_image_files,
                           splitter=splitter,
                           get_y=parent_label)
        return cls.from_dblock(dblock, path, path=path, **kwargs)

    @classmethod
    @delegates(DataBunch.from_dblock)
    def from_name_re(cls, path, fnames, pat, valid_pct=0.2, seed=None, **kwargs):
        "Create from list of `fnames` in `path`s with re expression `pat`."
        splitter = RandomSplitter(valid_pct, seed=seed)
        dblock = DataBlock(types=(PILImage, Category),
                           get_items=noop,
                           splitter=splitter,
                           get_y=RegexLabeller(pat))
        return cls.from_dblock(dblock, fnames, path=path, **kwargs)

#Cell
def get_grid(n, rows=None, cols=None, add_vert=0, figsize=None, double=False, title=None):
    rows = rows or int(np.ceil(math.sqrt(n)))
    cols = cols or int(np.ceil(n/rows))
    if double: cols*=2 ; n*=2
    figsize = (cols*3, rows*3+add_vert) if figsize is None else figsize
    fig,axs = subplots(rows, cols, figsize=figsize)
    axs = axs.flatten()
    for ax in axs[n:]: ax.set_axis_off()
    if title is not None: fig.suptitle(title, weight='bold', size=14)
    return axs

#Cell
@typedispatch
def show_batch(x:TensorImage, y, samples, ctxs=None, max_n=10, rows=None, cols=None, figsize=None, **kwargs):
    if ctxs is None: ctxs = get_grid(min(len(samples), max_n), rows=rows, cols=cols, figsize=figsize)
    ctxs = show_batch[object](x, y, samples, ctxs=ctxs, max_n=max_n, **kwargs)
    return ctxs

#Cell
def clip_remove_empty(bbox, label):
    "Clip bounding boxes with image border and label background the empty ones."
    bbox = torch.clamp(bbox, -1, 1)
    empty = ((bbox[...,2] - bbox[...,0])*(bbox[...,3] - bbox[...,1]) < 0.)
    return (bbox[~empty], label[~empty])

#Cell
def bb_pad(samples, pad_idx=0):
    "Function that collect `samples` of labelled bboxes and adds padding with `pad_idx`."
    samples = [(s[0], *clip_remove_empty(*s[1:])) for s in samples]
    max_len = max([len(s[2]) for s in samples])
    def _f(img,bbox,lbl):
        bbox = torch.cat([bbox,bbox.new_zeros(max_len-bbox.shape[0], 4)])
        lbl  = torch.cat([lbl, lbl .new_zeros(max_len-lbl .shape[0])+pad_idx])
        return img,bbox,lbl
    return [_f(*s) for s in samples]

#Cell
ImageBlock = TransformBlock(type_tfms=PILImage.create, batch_tfms=IntToFloatTensor)

#Cell
ImageBWBlock = TransformBlock(type_tfms=PILImageBW.create, batch_tfms=IntToFloatTensor)

#Cell
MaskBlock = TransformBlock(type_tfms=PILMask.create, batch_tfms=IntToFloatTensor)

#Cell
PointBlock = TransformBlock(type_tfms=TensorPoint.create, item_tfms=PointScaler)

#Cell
BBoxBlock = TransformBlock(type_tfms=TensorBBox.create, item_tfms=PointScaler, dbunch_kwargs = {'before_batch': bb_pad})

#Cell
def BBoxLblBlock(vocab=None, add_na=True):
    return TransformBlock(type_tfms=MultiCategorize(vocab=vocab, add_na=add_na), item_tfms=BBoxLabeler)