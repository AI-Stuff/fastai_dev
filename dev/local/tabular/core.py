#AUTOGENERATED! DO NOT EDIT! File to edit: dev/40_tabular_core.ipynb (unless otherwise specified).

__all__ = ['TabularProc', 'Tabular', 'Categorify', 'Normalize', 'FillStrategy', 'FillMissing', 'TabularPreprocessor',
           'process_df', 'TabularLine', 'TensorTabular', 'ReadTabLine', 'ReadTabTarget']

from ..imports import *
from ..test import *
from ..core import *
from ..data.all import *
from ..notebook.showdoc import show_doc

from pandas.api.types import is_numeric_dtype

class TabularProc(Transform):
    "Base class to write a tabular processor for dataframes"
    def __call__(self, to, **kwargs):
        self.process(to)
        return to

class Tabular(CollBase):
    def __init__(self, df, cat_names=None, cont_names=None, cat_y=None, splits=None):
        super().__init__(df)
        self.splits = L(ifnone(splits,[None]))
        self.cat_names,self.cont_names,self.cat_y = L(cat_names),L(cont_names),cat_y

    def __setitem__(self,k,v): super().__setitem__(list(k) if isinstance(k,L) else k, v)
    def transform(self, cols, f): self[cols] = self[cols].transform(f)

    @property
    def loc(self): return self.items.loc
    @property
    def iloc(self): return self.items.iloc

    @property
    def all_cat_names(self): return self.cat_names + self.cat_y
    @property
    def all_col_names(self): return self.cont_names + self.all_cat_names
    @property
    def classes(self): return {n:'#na#'+L(c.cat.categories) for n,c in self.all_cats.items()}

def _add_prop(cls, nm):
    prop = property(lambda o: o.items[list(getattr(o,nm+'_names'))])
    setattr(cls, nm+'s', prop)
    def _f(o,v): o.items[list(getattr(o,nm+'_names'))] = v
    setattr(cls, nm+'s', prop.setter(_f))

_add_prop(Tabular, 'cat')
_add_prop(Tabular, 'all_cat')
_add_prop(Tabular, 'cont')
_add_prop(Tabular, 'all_col')

class Categorify(TabularProc):
    "Transform the categorical variables to that type."
    order = 1
    def setup(self, to):
        self.categories = {}
        for n in to.all_cat_names:
            col = to.loc[ifnone(to.splits[0], slice(None)),n]
            self.categories[n] = pd.Categorical(col, ordered=True).categories

    def process(self, to):
        to.transform(to.all_cat_names, lambda c: pd.Categorical(c, categories=self.categories[c.name], ordered=True))

    def decodes(self, to):
        cats = [self.categories[c][v-1] if v > 0 else '#na' for v,c in zip(to.items[0], to.cat_names)]
        to.items = (cats, to.items[1])
        return to

class Normalize(TabularProc):
    "Normalize the continuous variables."
    order = 2
    def setup(self, to):
        df = to.loc[ifnone(to.splits[0],slice(None)), to.cont_names]
        self.means,self.stds = df.mean(),df.std(ddof=0)

    def process(self, to): to.conts = (to.conts-self.means) / (self.stds+1e-7)

    def decodes(self, to):
        conts = [(v*self.stds[c] + self.means[c]).item() for v,c in zip(to.items[1], to.cont_names)]
        to.items = (to.items[0], conts)
        return to

mk_class('FillStrategy', **{o:o for o in ['median', 'constant', 'most_common']})
FillStrategy.__doc__ = "Namespace containing the various filling strategies"

class FillMissing(TabularProc):
    "Fill the missing values in continuous columns."
    def __init__(self, fill_strategy=FillStrategy.median, add_col=True, fill_val=0.):
        store_attr(self, 'fill_strategy,add_col,fill_val')

    def setup(self, to):
        self.na_dict = {}
        df = to.loc[ifnone(to.splits[0],slice(None)), to.cont_names]
        for n in to.cont_names:
            col = df[n]
            if pd.isnull(col).sum():
                self.na_dict[n] = {
                    FillStrategy.median:      col.median(),
                    FillStrategy.constant:    self.fill_val,
                    FillStrategy.most_common: col.dropna().value_counts().idxmax()
                }[self.fill_strategy]

    def process(self, to):
        for n in to.cont_names:
            if n in self.na_dict:
                if self.add_col:
                    to[n+'_na'] = pd.isnull(to[n])
                    if n+'_na' not in to.cat_names: to.cat_names.append(n+'_na')
                to[n] = to[n].fillna(self.na_dict[n])
            elif pd.isnull(to[n]).sum() != 0:
                raise Exception(f"""There are nan values in field {n} but there were none in the training set given at setup.
                Please fix those manually.""")

class TabularPreprocessor(GetAttr):
    "An object that will preprocess dataframes using `procs`"
    def __init__(self, procs):
        procs = L(procs).sorted(key='order')
        self.procs = {p:(p() if isinstance(p, type) else TabularProc(p)) for p in procs}

    def setup(self, to):
        self.default = self.to = to
        self.procs,procs = {},self.procs
        for t,p in procs.items():
            getattr(p, 'setup', noop)(to)
            getattr(p, 'process', noop)(to)
            self.procs[t] = p

    def __call__(self, to):
        "Call each of `self.procs` on `df`, setup on `df[trn_idx]` if not None"
        for p in self.procs.values(): p(to)

def process_df(df, splits, procs, cat_names=None, cont_names=None, cat_y=None, inplace=True):
    "Process `df` with `procs` and returns the processed dataframe and the `TabularProcessor` associated"
    to = Tabular(df if inplace else df.copy(), cat_names, cont_names, cat_y, splits)
    proc = Pipeline(procs)
    proc.setup(to)
    return to,proc

class TabularLine(pd.Series):
    "A line of a dataframe that knows how to show itself"
    def show(self, ctx=None, **kwargs):
        if ctx is None: return self
        else: return ctx.append(self)

class TensorTabular(tuple):

    def get_ctxs(self, max_samples=10, **kwargs):
        n_samples = min(self[0].shape[0], max_samples)
        df = pd.DataFrame(index = range(n_samples))
        return [df.iloc[i] for i in range(n_samples)]

    def display(self, ctxs): display_df(pd.DataFrame(ctxs))

class ReadTabLine(ItemTransform):
    def __init__(self, proc):
        self.proc = proc
        self.o2is = {n: defaultdict(int, {v:i for i,v in enumerate(proc.classes[n])}) for n in proc.cat_names}

    def encodes(self, row):
        cats = [self.o2is[n][row[n]] for n in self.proc.cat_names]
        conts = [row[n] for n in self.proc.cont_names]
        return TensorTabular((tensor(cats).long(),tensor(conts).float()))

    def decodes(self, o) -> TabularLine:
        to = Tabular(o, self.proc.cat_names, self.proc.cont_names, self.proc.cat_y)
        to = self.proc.decode(to)
        return pd.Series({c: v for v,c in zip(to.items[0]+to.items[1], self.proc.cat_names+self.proc.cont_names)})

class ReadTabTarget(ItemTransform):
    def __init__(self, proc):
        self.proc = proc
        self.o2i = defaultdict(int, {v:i for i,v in enumerate(proc.classes[proc.cat_y])})

    def encodes(self, row): return self.o2i[row[self.proc.cat_y]]-1
    def decodes(self, o) -> Category: return self.proc.classes[self.proc.cat_y][o+1]