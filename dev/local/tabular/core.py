#AUTOGENERATED! DO NOT EDIT! File to edit: dev/40_tabular_core.ipynb (unless otherwise specified).

__all__ = ['TabularProc', 'Categorify', 'Normalize', 'FillStrategy', 'FillMissing', 'TabularPreprocessor', 'process_df',
           'TabularLine', 'TensorTabular', 'ReadTabLine', 'ReadTabTarget']

from ..imports import *
from ..test import *
from ..core import *
from ..data.all import *
from ..notebook.showdoc import show_doc

from pandas.api.types import is_numeric_dtype

@docs
class TabularProc():
    "Base class to write a tabular processor for dataframes"
    setup,__call__,order = noops,noops,0
    def __init__(self, func=None): self.__call__ = ifnone(func, self.__call__)

    _docs = dict(setup="Use `df` to set its state, with just `trn_idx` if passed",
                 __call__="Process `df` with the state computed during setup`")

class Categorify(TabularProc):
    "Transform the categorical variables to that type."
    order = 1
    def setup(self, to, trn_idx=None):
        self.categories = {}
        for n in to.all_cat_names:
            col = to.loc[ifnone(trn_idx, slice(None)),n]
            self.categories[n] = pd.Categorical(col, ordered=True).categories

    def __call__(self, to):
        for n in to.all_cat_names:
            to.loc[:,n] = pd.Categorical(to.loc[:,n], categories=self.categories[n], ordered=True)

class Normalize(TabularProc):
    "Normalize the continuous variables."
    order = 2
    def setup(self, to, trn_idx=None):
        self.means,self.stds = {},{}
        for n in to.cont_names:
            assert is_numeric_dtype(df[n]), (f"""Cannot normalize '{n}' column as it isn't numerical.
                Are you sure it doesn't belong in the categorical set of columns?""")
            col = (to[n] if trn_idx is None else to.loc[trn_idx,n])
            self.means[n],self.stds[n] = col.mean(),col.std(ddof=0)

    def __call__(self, to):
        for n in to.cont_names: to[n] = (to[n]-self.means[n]) / (1e-7 + self.stds[n])

mk_class('FillStrategy', **{o:o for o in ['median', 'constant', 'most_common']})
FillStrategy.__doc__ = "Namespace containing the various filling strategies"

class FillMissing(TabularProc):
    "Fill the missing values in continuous columns."
    def __init__(self, fill_strategy=FillStrategy.median, add_col=True, fill_val=0.):
        store_attr(self, 'fill_strategy,add_col,fill_val')

    def setup(self, to, trn_idx=None):
        self.na_dict = {}
        for n in to.cont_names:
            col = to[n] if trn_idx is None else to.loc[trn_idx,n]
            if pd.isnull(col).sum():
                if self.fill_strategy == FillStrategy.median: filler = col.median()
                elif self.fill_strategy == FillStrategy.constant: filler = self.fill_val
                else: filler = col.dropna().value_counts().idxmax()
                self.na_dict[n] = filler

    def __call__(self, to):
        for n in to.cont_names:
            if n in self.na_dict:
                if self.add_col:
                    to[n+'_na'] = pd.isnull(to[n])
                    if n+'_na' not in to.cat_names: to.cat_names.append(n+'_na')
                to[n] = to[n].fillna(self.na_dict[n])
            elif pd.isnull(to[n]).sum() != 0:
                raise Exception(f"""There are nan values in field {n} but there were none in the training set given at setup.
                Please fix those manually.""")

class TabularPreprocessor(GetAttr):
    "An object that will preprocess dataframes using `procs`"
    def __init__(self, procs, inplace=True):
        self.inplace = inplace
        procs = L(procs).sorted(key='order')
        self.procs = {p:(p() if isinstance(p, type) else TabularProc(func=p)) for p in procs}

    def __call__(self, to, trn_idx=None):
        "Call each of `self.procs` on `df`, setup on `df[trn_idx]` if not None"
        if not self.inplace: to.set_items(to.items.copy())
        if trn_idx is None:
            for p in self.procs.values(): p(to)
        else:
            self.default = self.to = to
            self.procs,procs = {},self.procs
            for t,p in procs.items():
                p.setup(to, trn_idx=trn_idx)
                p(to)
                self.procs[t] = p

def process_df(df, splits, procs, cat_names=None, cont_names=None, cat_y=None, inplace=True):
    "Process `df` with `procs` and returns the processed dataframe and the `TabularProcessor` associated"
    to = Tabular(df, cat_names, cont_names, cat_y)
    proc = TabularPreprocessor(procs, inplace=inplace)
    proc(to, trn_idx=splits[0])
    return to,proc

class TabularLine(pd.Series):
    "A line of a dataframe that knows how to show itself"
    def show(self, ctx=None, **kwargs):
        if ctx is None: return self
        else: return ctx.append(self)

class TensorTabular(tuple):

    def get_ctxs(self, max_samples=10, **kwargs):
        n_samples = min(self[0].shape[0], max_samples)
        df = pd.DataFrame(index = range(n_samples))
        return [df.iloc[i] for i in range(n_samples)]

    def display(self, ctxs): display_df(pd.DataFrame(ctxs))

class ReadTabLine(ItemTransform):
    def __init__(self, proc):
        self.proc = proc
        self.o2is = {n: defaultdict(int, {v:i for i,v in enumerate(proc.classes[n])}) for n in proc.cat_names}

    def encodes(self, row):
        cats = [self.o2is[n][row[n]] for n in self.proc.cat_names]
        conts = [row[n] for n in self.proc.cont_names]
        return TensorTabular((tensor(cats).long(),tensor(conts).float()))

    def decodes(self, o) -> TabularLine:
        dic = {c: self.proc.classes[c][v] for v,c in zip(o[0], self.proc.cat_names)}
        norm = self.proc.procs.get(Normalize, None)
        if norm is not None:
            dic.update({c: (v*norm.stds[c] + norm.means[c]).item() for v,c in zip(o[1], self.proc.cont_names)})
        return pd.Series(dic)

class ReadTabTarget(ItemTransform):
    def __init__(self, proc):
        self.proc = proc
        self.o2i = defaultdict(int, {v:i for i,v in enumerate(proc.classes[proc.cat_y])})

    def encodes(self, row): return self.o2i[row[self.proc.cat_y]]-1
    def decodes(self, o) -> Category: return self.proc.classes[self.proc.cat_y][o+1]